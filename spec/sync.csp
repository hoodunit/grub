NUM_CLIENTS = 4
NUM_DB_STATES = 10
CLIENTS = {0..NUM_CLIENTS-1}
TIMES = {0..NUM_DB_STATES-1}

channel save:CLIENTS
channel render:CLIENTS.TIMES
channel up:CLIENTS.TIMES
channel down:CLIENTS.TIMES
channel saved:CLIENTS.TIMES
channel report_queue:CLIENTS.TIMES

next_t(t) = (t + 1) % NUM_DB_STATES

CLIENT(i, t) = 
   up!i!t -> CLIENT'(i, t)
[] CLIENT'(i, t)

CLIENT'(i, t) = 
   down!i?server_t
   -> render!i!server_t
   -> CLIENT(i, server_t)

SERVER(i, client_t) = 
   up!i?server_t
   -> save!i
   -> saved!i?new_server_t
   -> down!i!new_server_t
   -> SERVER(i, new_server_t)
[] report_queue?j:diff(CLIENTS,{i})?new_server_t
   -> if new_server_t == client_t
      then SERVER(i, client_t)
      else down!i!new_server_t
        -> SERVER(i, new_server_t)

DB(t) =
   save?i
   -> saved!i!next_t(t)
   -> DB(next_t(t))

REPORTQUEUE(i) =
   saved?j:diff(CLIENTS,{i})?t
   -> REPORTQUEUE'(i, j, t)
REPORTQUEUE'(i, j, t) =
   saved?j':diff(CLIENTS,{i})?new_t
   -> REPORTQUEUE'(i, j', new_t)
[] report_queue!j!t -> REPORTQUEUE(i)

SERVER_WITH_REPORTS(i, t0) = (SERVER(i, t0) [|{| report_queue |}|] REPORTQUEUE(i))
CONN(i, t0) = CLIENT(i, t0) [|{| up.i, down.i |}|] SERVER_WITH_REPORTS(i, t0)
CONNS(numClients, t0) = [| productions(saved) |] i:{0..numClients-1} @ CONN(i, t0)
SYSTEM(numClients) = DB(0) [|{| save, saved |}|] CONNS(numClients, 0)

-----------------------------------------
-- One way sync: a change on one client will sync to another
-----------------------------------------

-- Constrain our implementation to allow each
-- user only a finite number of changes n.
MaxInputs(0) = SKIP
MaxInputs(n) = up?i?t -> MaxInputs(n-1)

-- Constrain our implementation to allow
-- only changes from a single client.

OnlyInputFromClient(i) = up!i?t -> OnlyInputFromClient(i)

-- Show that, given two connected clients client 0 and client 1,
-- a single change on client 0 will make it to client 1.

-- Our constrained implementation, which allows one input from
-- client 0 and then ends:
OneInputFromClientZeroSystem = (SYSTEM(2) [|{| up |}|] MaxInputs(1)) [|{| up |}|] OnlyInputFromClient(0)

-- Specification: a single change on client 0 will make it to client 1.
SyncOneInput = up.0.0 -> render.1.1 -> STOP

-- Assertion: our constrained system fulfills this specification.
assert SyncOneInput [FD= OneInputFromClientZeroSystem \diff(Events, union(productions(up.0), {render.1.1}))

-----------------------------------------
-- One way sync: n changes on one client will sync to another client
-----------------------------------------

-- Specification: client 0 makes n changes
-- and client 1 renders with the last of those changes.

SyncNInputs(n) = up.0.0 -> SyncNInputs'(n, n-1)
SyncNInputs'(n, 0) = render.1.n -> STOP
SyncNInputs'(n, i) = up.0.n-i -> SyncNInputs'(n, i-1)

-- Constraint: allow n inputs from client 0
NInputsFromClientZeroSystem(n) = (SYSTEM(2) [|{| up |}|] MaxInputs(n)) [|{| up |}|] OnlyInputFromClient(0)

assert SyncNInputs(1) [FD= NInputsFromClientZeroSystem(1) \diff(Events, union(productions(up.0), {render.1.1}))
assert SyncNInputs(9) [FD= NInputsFromClientZeroSystem(9) \diff(Events, union(productions(up.0), {render.1.9}))

-----------------------------------------
-- Two way sync: changes on both clients will sync to both
-----------------------------------------

-- Let's constrain our system to say, first client 0 
-- does a change then client 1 does a change.

AlternateInputs = up.0.0 -> up.1?t -> STOP

-- Then our specification becomes simple. If client 0 inputs something 
-- and then client one inputs something, at some point both should call 
-- render with the state after both changes hit the database (t=2).
TwoWaySync = up.0.0 -> ((up.1.0 -> TwoWaySyncRender) |~|
                        (up.1.1 -> TwoWaySyncRender))
TwoWaySyncRender = ((render.0.2 -> render.1.2 -> STOP) |~|
                    (render.1.2 -> render.0.2 -> STOP))

assert TwoWaySync [FD= (SYSTEM(2) [|{| up |}|] AlternateInputs) \diff(Events, union(union(productions(up.0), productions(up.1)), {render.0.2, render.1.2}))

-----------------------------------------
-- N way eventual sync: changes on n clients will sync to all
-----------------------------------------

-- Specification: n changes are made, where a change can be
-- made on any client, and then render is called with each 
-- of the clients in any order

sequences({}) = {<>}
sequences(a) = {<z>^z' | z <- a, z' <- sequences(diff(a, {z}))}

renderAll(sequence, t) = ; i:sequence @ render!i.t -> SKIP

SyncAll(numClients, n) = |~| i:{0..numClients-1} @ up!i!0 -> SyncAll'(numClients, n, n-1)
SyncAll'(numClients, n, 0) = |~| renderSeq:sequences({0..numClients-1}) @ renderAll(renderSeq, n); STOP
SyncAll'(numClients, n, m) = |~| i:{0..numClients-1}, t:TIMES @ up!i!t -> SyncAll'(numClients, n, m-1)

-- Helper function: a system where only n inputs are allowed.
MaxInputSystem(numClients, n) = SYSTEM(numClients) [|{| up |}|] MaxInputs(n)

-- Number of clients: 4
-- Number of changes allowed: 1, 5, 9
assert SyncAll(4, 1) [FD= MaxInputSystem(4, 1) \diff(Events, union(productions(up), {render.i.1 | i <- {0..3}}))
assert SyncAll(4, 5) [FD= MaxInputSystem(4, 5) \diff(Events, union(productions(up), {render.i.5 | i <- {0..3}}))
assert SyncAll(5, 9) [FD= MaxInputSystem(4, 9) \diff(Events, union(productions(up), {render.i.9 | i <- {0..3}}))

-- This proves that given n clients, if we restrict them to x inputs total from any client in any order, eventually all n clients will render the same state i.e. they will be in sync.
-- Note that this doesn't say anything about timing other except that eventually it will happen. 